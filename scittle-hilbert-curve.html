<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>LZ</title>
<meta name="generator" content="Org Mode" />
<link rel ="stylesheet" type= "text/css" href="./styles.css"><link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ‘»</text></svg>">
</head>
<body>
<div id="content" class="content">
<h1 class="title">LZ</h1>
<p>
<a href="./index.html">home</a>
</p>

<script src="https://cdn.jsdelivr.net/npm/scittle@0.5.14/dist/scittle.js"
        type="application/javascript"></script>
<script type="application/x-scittle">
  (defn my-alert []
   (js/alert "You clicked!"))
  ;; export function to use from JavaScript:
  (set! (.-my_alert js/window) my-alert)
</script>

<p>
Let's make a hilbert curve on is page in Clojure (the one 
&#10084) and allow the reader to manipulate the code in-place.
</p>

<div id="outline-container-orgeb9c392" class="outline-2">
<h2 id="orgeb9c392">what is a hilbert curve?</h2>
<div class="outline-text-2" id="text-orgeb9c392">
<p>
A <a href="http://en.wikipedia.org/wiki/Hilbert_curve">Hibert Curve</a> is a space-filling fractal. it's useful for mapping 2 dimensional space stuff onto 1 dimension. I like it because it looks good.
</p>


<div id="orgf9c7075" class="figure">
<p><img src="images/HC-3-iterations.png" alt="HC-3-iterations.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org0a37c84" class="outline-2">
<h2 id="org0a37c84">what is scittle?</h2>
<div class="outline-text-2" id="text-org0a37c84">
<p>
<a href="https://github.com/babashka/scittle">Scittle</a> is is a small Clojure interpreter designed to be embedded inside web pages using html <code>&lt;script&gt;</code> tags. For example to evaluate code input by the user.
</p>
</div>

<div id="outline-container-org918e716" class="outline-3">
<h3 id="org918e716">Aside</h3>
<div class="outline-text-3" id="text-org918e716">
<p>
It's great how simple Scittle is to use inside this blog. I'm writing in an <a href="https://orgmode.org">org file</a> in Emacs. I embed some script tags in a <a href="https://orgmode.org/manual/Quoting-HTML-tags.html">export block</a>. Like so:
</p>

<div class="org-src-container">
<pre class="src src-html">#+begin_export html
&lt;<span class="org-function-name">script</span> <span class="org-variable-name">src</span>=<span class="org-string">"https://cdn.jsdelivr.net/npm/scittle@0.5.14/dist/scittle.js"</span>
        <span class="org-variable-name">type</span>=<span class="org-string">"application/javascript"</span>&gt;&lt;/<span class="org-function-name">script</span>&gt;
&lt;<span class="org-function-name">script</span> <span class="org-variable-name">type</span>=<span class="org-string">"application/x-scittle"</span>&gt;
  (defn my-alert []
   (js/alert "You clicked!"))
  ;; export function to use from JavaScript:
  (set! (.-my_alert js/window) my-alert)
&lt;/<span class="org-function-name">script</span>&gt;

&lt;<span class="org-function-name">body</span>&gt;
  &lt;<span class="org-function-name">button</span> <span class="org-variable-name">onclick</span>=<span class="org-string">"my_alert()"</span>&gt;
    Click me!
  &lt;/<span class="org-function-name">button</span>&gt;
&lt;/<span class="org-function-name">body</span>&gt;
#+end_export
</pre>
</div>

<body>
  <button onclick="my_alert()">
    Click me!
  </button>
</body>


<p>
Then I run my regular <a href="how-this-blog-works.html">build script</a> and away we go, running Clojure in my blog post via skittle via js via org-mode-export with practically no extra configuration at all. That's wild.
</p>
</div>
</div>
</div>

<div id="outline-container-orgf4595f7" class="outline-2">
<h2 id="orgf4595f7">handle user input code</h2>
<div class="outline-text-2" id="text-orgf4595f7">
<p>
First let's make a <code>textarea</code> in html to get the user input. We'd like a button to click evaluate what the user enters. Then output the result beneath.
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span class="org-function-name">script</span> <span class="org-variable-name">type</span>=<span class="org-string">"application/x-scittle"</span>&gt;

(defn set-output-area [v output-id]
  (-&gt; (js/document.getElementById output-id)
      (.-innerHTML)
      (set! v)))

(defn try-eval [v]
  (try (js/scittle.core.eval_string v)
    (catch js/Error e
      (str "ERROR: " e))))

(defn read-eval-input [input-id]
  (-&gt; input-id
      js/document.getElementById 
      .-value
      try-eval))

(set! (.-read_input js/window)
      #(set-output-area (read-eval-input "code-area")
                        "output-area"))

&lt;/<span class="org-function-name">script</span>&gt;
&lt;<span class="org-function-name">body</span>&gt;
&lt;<span class="org-function-name">textarea</span> <span class="org-variable-name">id</span>=<span class="org-string">"code-area"</span>
          <span class="org-variable-name">class</span>=<span class="org-string">"code-textarea"</span>&gt;
(take 21 ((fn fib [a b] (lazy-seq (cons a (fib b (+ a b))))) 0 1))
&lt;/<span class="org-function-name">textarea</span>&gt;
&lt;<span class="org-function-name">button</span> <span class="org-variable-name">onclick</span>=<span class="org-string">"read_input()"</span>&gt;eval&lt;/<span class="org-function-name">button</span>&gt;
&lt;<span class="org-function-name">p</span> <span class="org-variable-name">id</span>=<span class="org-string">"output-area"</span>&gt;...&lt;/<span class="org-function-name">p</span>&gt;
&lt;/<span class="org-function-name">body</span>&gt;
</pre>
</div>

<script type="application/x-scittle">

(defn set-output-area [v output-id]
  (-> (js/document.getElementById output-id)
      (.-innerHTML)
      (set! v)))

(defn try-eval [v]
  (try (js/scittle.core.eval_string v)
    (catch js/Error e
      (str "ERROR: " e))))

(defn read-eval-input [input-id]
  (-> input-id
      js/document.getElementById 
      .-value
      try-eval))

(set! (.-read_input js/window)
      #(set-output-area (read-eval-input "code-area")
                        "output-area"))
 
</script>
<body>
<textarea id="code-area"
          class="code-textarea"
	  spellcheck="false">
(take 21 ((fn fib [a b] (lazy-seq (cons a (fib b (+ a b))))) 0 1))
</textarea>
<button onclick="read_input()">eval</button>
<p id="output-area">...</p>
</body>

<p>
Right nice.
</p>
</div>
</div>

<div id="outline-container-org28a713a" class="outline-2">
<h2 id="org28a713a">drawing</h2>
<div class="outline-text-2" id="text-org28a713a">
<p>
I think the easiest way to do this will be with <code>canvas</code>.
</p>


<div class="org-src-container">
<pre class="src src-html">&lt;<span class="org-function-name">canvas</span> <span class="org-variable-name">id</span>=<span class="org-string">"first-canvas"</span> <span class="org-variable-name">width</span>=<span class="org-string">"400"</span> <span class="org-variable-name">height</span>=<span class="org-string">"400"</span> <span class="org-variable-name">class</span>=<span class="org-string">"canvas"</span>&gt;&lt;/<span class="org-function-name">canvas</span>&gt;

&lt;<span class="org-function-name">script</span> <span class="org-variable-name">type</span>=<span class="org-string">"application/x-scittle"</span>&gt;  
(def c (js/document.getElementById "first-canvas"))
(def ctx (.getContext c "2d"))

(.moveTo ctx 50 50)
(.lineTo ctx 50 150)
(.lineTo ctx 150 150)
(.lineTo ctx 150 50)
(.stroke ctx)
&lt;/<span class="org-function-name">script</span>&gt;
</pre>
</div>



<canvas id="first-canvas" width="200" height="200" class="canvas"></canvas>

<script type="application/x-scittle">  
(def c (js/document.getElementById "first-canvas"))
(def ctx (.getContext c "2d"))

(.moveTo ctx 50 50)
(.lineTo ctx 50 150)
(.lineTo ctx 150 150)
(.lineTo ctx 150 50)
(.stroke ctx)
</script>

<p>
Let's have it so that the user can pass in an vector of points that the line will go through:
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span class="org-function-name">canvas</span> <span class="org-variable-name">id</span>=<span class="org-string">"points-canvas"</span> <span class="org-variable-name">width</span>=<span class="org-string">"200"</span> <span class="org-variable-name">height</span>=<span class="org-string">"200"</span> <span class="org-variable-name">class</span>=<span class="org-string">"canvas"</span>&gt;&lt;/<span class="org-function-name">canvas</span>&gt;

&lt;<span class="org-function-name">script</span> <span class="org-variable-name">type</span>=<span class="org-string">"application/x-scittle"</span>&gt;

(def c (js/document.getElementById "user-points-canvas"))
(def ctx (.getContext c "2d"))

(defn try-eval [v]
  (try (js/scittle.core.eval_string v)
    (catch js/Error e
      (str "ERROR: " e))))

(defn read-eval-input [input-id]
  (-&gt; input-id
      js/document.getElementById 
      .-value
      try-eval))

(defn draw-line-from-points [context points]
  (.clearRect context 0 0 (.-width c) (.-height c))
  (.beginPath context)
  (.moveTo context (-&gt; points first first) (-&gt; points first second))
  (doseq [[x y] (rest points)]
    (.lineTo context x y))
  (.stroke context))

(set! (.-read_points js/window)
      #(-&gt;&gt; (read-eval-input "points-input")
            (draw-line-from-points ctx)))

&lt;/<span class="org-function-name">script</span>&gt;
&lt;<span class="org-function-name">body</span>&gt;
&lt;<span class="org-function-name">textarea</span> <span class="org-variable-name">id</span>=<span class="org-string">"points-input"</span>
          <span class="org-variable-name">class</span>=<span class="org-string">"code-textarea"</span>&gt;
[[50 50] [50 150] [150 150] [150 50]]
&lt;/<span class="org-function-name">textarea</span>&gt;
&lt;<span class="org-function-name">button</span> <span class="org-variable-name">onclick</span>=<span class="org-string">"read_points()"</span>&gt;Draw points&lt;/<span class="org-function-name">button</span>&gt;
&lt;/<span class="org-function-name">body</span>&gt;
</pre>
</div>

<canvas id="points-canvas" width="200" height="200" class="canvas"></canvas>

<script type="application/x-scittle">

(def c (js/document.getElementById "points-canvas"))
(def ctx (.getContext c "2d"))

(defn try-eval [v]
  (try (js/scittle.core.eval_string v)
    (catch js/Error e
      (str "ERROR: " e))))

(defn read-eval-input [input-id]
  (-> input-id
      js/document.getElementById 
      .-value
      try-eval))

(defn draw-line-from-points [context points]
  (.clearRect context 0 0 (.-width c) (.-height c))
  (.beginPath context)
  (.moveTo context (-> points first first) (-> points first second))
  (doseq [[x y] (rest points)]
    (.lineTo context x y))
  (.stroke context))

(set! (.-read_points js/window)
      #(->> (read-eval-input "points-input")
            (draw-line-from-points ctx)))

</script>
<body>
<textarea id="points-input"
          class="code-textarea"
	  spellcheck="false">
[[50 50] [50 150] [150 150] [150 50]]
</textarea>
<button onclick="read_points()">Draw points</button>
</body>

<p>
Now it's just a matter of choosing the right points.
</p>
</div>
</div>

<div id="outline-container-org24d7163" class="outline-2">
<h2 id="org24d7163">making the hilbert curve</h2>
<div class="outline-text-2" id="text-org24d7163">
<p>
How this fractal works is that there are four patterns, and each one of these four pattern can be split up into quarters, and each one of those quarters can be swapped for one of the original four patterns. Recursion.
</p>

<p>
Here's the details of that mapping:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">def</span> <span class="org-variable-name">rules</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-clojure-keyword">:A</span> <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-clojure-keyword">:path</span> <span class="org-rainbow-delimiters-depth-4">[</span><span class="org-rainbow-delimiters-depth-5">[</span>0 0<span class="org-rainbow-delimiters-depth-5">]</span> <span class="org-rainbow-delimiters-depth-5">[</span>0 1<span class="org-rainbow-delimiters-depth-5">]</span> <span class="org-rainbow-delimiters-depth-5">[</span>1 1<span class="org-rainbow-delimiters-depth-5">]</span> <span class="org-rainbow-delimiters-depth-5">[</span>1 0<span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">]</span>
                <span class="org-clojure-keyword">:next-iteration</span> <span class="org-rainbow-delimiters-depth-4">[</span><span class="org-clojure-keyword">:D</span> <span class="org-clojure-keyword">:A</span> <span class="org-clojure-keyword">:A</span> <span class="org-clojure-keyword">:B</span><span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">}</span>
            <span class="org-clojure-keyword">:B</span> <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-clojure-keyword">:path</span> <span class="org-rainbow-delimiters-depth-4">[</span><span class="org-rainbow-delimiters-depth-5">[</span>1 1<span class="org-rainbow-delimiters-depth-5">]</span> <span class="org-rainbow-delimiters-depth-5">[</span>0 1<span class="org-rainbow-delimiters-depth-5">]</span> <span class="org-rainbow-delimiters-depth-5">[</span>0 0<span class="org-rainbow-delimiters-depth-5">]</span> <span class="org-rainbow-delimiters-depth-5">[</span>1 0<span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">]</span>
                <span class="org-clojure-keyword">:next-iteration</span> <span class="org-rainbow-delimiters-depth-4">[</span><span class="org-clojure-keyword">:C</span> <span class="org-clojure-keyword">:B</span> <span class="org-clojure-keyword">:B</span> <span class="org-clojure-keyword">:A</span><span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">}</span>
            <span class="org-clojure-keyword">:C</span> <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-clojure-keyword">:path</span> <span class="org-rainbow-delimiters-depth-4">[</span><span class="org-rainbow-delimiters-depth-5">[</span>1 1<span class="org-rainbow-delimiters-depth-5">]</span> <span class="org-rainbow-delimiters-depth-5">[</span>1 0<span class="org-rainbow-delimiters-depth-5">]</span> <span class="org-rainbow-delimiters-depth-5">[</span>0 0<span class="org-rainbow-delimiters-depth-5">]</span> <span class="org-rainbow-delimiters-depth-5">[</span>0 1<span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">]</span>
                <span class="org-clojure-keyword">:next-iteration</span> <span class="org-rainbow-delimiters-depth-4">[</span><span class="org-clojure-keyword">:B</span> <span class="org-clojure-keyword">:C</span> <span class="org-clojure-keyword">:C</span> <span class="org-clojure-keyword">:D</span><span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">}</span>
            <span class="org-clojure-keyword">:D</span> <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-clojure-keyword">:path</span> <span class="org-rainbow-delimiters-depth-4">[</span><span class="org-rainbow-delimiters-depth-5">[</span>0 0<span class="org-rainbow-delimiters-depth-5">]</span> <span class="org-rainbow-delimiters-depth-5">[</span>1 0<span class="org-rainbow-delimiters-depth-5">]</span> <span class="org-rainbow-delimiters-depth-5">[</span>1 1<span class="org-rainbow-delimiters-depth-5">]</span> <span class="org-rainbow-delimiters-depth-5">[</span>0 1<span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">]</span>
                <span class="org-clojure-keyword">:next-iteration</span> <span class="org-rainbow-delimiters-depth-4">[</span><span class="org-clojure-keyword">:A</span> <span class="org-clojure-keyword">:D</span> <span class="org-clojure-keyword">:D</span> <span class="org-clojure-keyword">:C</span><span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
So each path has four points we can think about it as tracing three sides of a square in a specific order. Let's say the origin is top-left, then the path for <code>:A</code> is from the origin, across the top, down the right side and from right to left across the bottom. The sides and the order we go through the points is all significant.
</p>

<p>
Let's think about our canvas as a square split up into square cells. The number of cells is controlled by the number of iterations we perform (4<sup>n</sup>). Each cell contains a pattern, we need to have the right order of cells and the right pattern for each. So we'll aim for a sequence of <code>cells</code>, where a <code>cell</code> is an [x, y] vector identifying the cell, and a pattern. Here's the zero'th iteration with a single cell in it:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">def</span> <span class="org-variable-name">init</span> <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">{</span><span class="org-clojure-keyword">:cell</span> <span class="org-rainbow-delimiters-depth-4">[</span>0 0<span class="org-rainbow-delimiters-depth-4">]</span> <span class="org-clojure-keyword">:pattern</span> <span class="org-clojure-keyword">:A</span><span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
To turn this into the next iteration we need to subdivide the space into four cells, and then add a pattern for each one:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">-&gt;subcells</span>
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">{</span><span class="org-clojure-keyword">:keys</span> <span class="org-rainbow-delimiters-depth-4">[</span>cell pattern<span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-3">[</span>top-left-subcell <span class="org-rainbow-delimiters-depth-4">(</span>map <span class="org-rainbow-delimiters-depth-5">(</span>partial * 2<span class="org-rainbow-delimiters-depth-5">)</span> cell<span class="org-rainbow-delimiters-depth-4">)</span>
        path-step-&gt;subcells <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">fn</span> <span class="org-rainbow-delimiters-depth-5">[</span>path-step<span class="org-rainbow-delimiters-depth-5">]</span>
                              <span class="org-rainbow-delimiters-depth-5">(</span>map + top-left-subcell
                                     path-step<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span> 
        path <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">-&gt;&gt;</span> rules
                  pattern
                  <span class="org-clojure-keyword">:path</span>
                  <span class="org-rainbow-delimiters-depth-5">(</span>map path-step-&gt;subcells<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
        cell-patterns <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">-&gt;</span> rules pattern <span class="org-clojure-keyword">:next-iteration</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">]</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>map <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">fn</span> <span class="org-rainbow-delimiters-depth-5">[</span>cell pattern<span class="org-rainbow-delimiters-depth-5">]</span>
           <span class="org-rainbow-delimiters-depth-5">{</span><span class="org-clojure-keyword">:cell</span> cell <span class="org-clojure-keyword">:pattern</span> pattern<span class="org-rainbow-delimiters-depth-5">}</span><span class="org-rainbow-delimiters-depth-4">)</span>
         path
         cell-patterns<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span>map -&gt;subcells init<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-comment-delimiter">;</span><span class="org-comment">=&gt; (({:cell (0 0), :pattern :D}</span>
<span class="org-comment-delimiter">;     </span><span class="org-comment">{:cell (0 1), :pattern :A}</span>
<span class="org-comment-delimiter">;     </span><span class="org-comment">{:cell (1 1), :pattern :A}</span>
<span class="org-comment-delimiter">;     </span><span class="org-comment">{:cell (1 0), :pattern :B}))</span>
</pre>
</div>

<p>
Okay, now we would like to iterate that, each time concatenating the results into a single sequence. 
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">hilbert-curve-cells</span> <span class="org-rainbow-delimiters-depth-2">[</span>iterations<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">-&gt;</span> <span class="org-rainbow-delimiters-depth-3">(</span>iterate #<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">-&gt;&gt;</span> <span class="org-variable-name">%</span> <span class="org-rainbow-delimiters-depth-5">(</span>map -&gt;subcells<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">(</span>apply concat<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span> init<span class="org-rainbow-delimiters-depth-3">)</span>
      <span class="org-rainbow-delimiters-depth-3">(</span>nth iterations<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span>hilbert-curve-cells 2<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-comment-delimiter">;</span><span class="org-comment">=&gt; ({:cell (0 0), :pattern :A}</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">{:cell (1 0), :pattern :D}</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">{:cell (1 1), :pattern :D}</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">{:cell (0 1), :pattern :C}</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">{:cell (0 2), :pattern :D}</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">{:cell (0 3), :pattern :A}</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">{:cell (1 3), :pattern :A}</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">{:cell (1 2), :pattern :B}</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">{:cell (2 2), :pattern :D}</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">{:cell (2 3), :pattern :A}</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">{:cell (3 3), :pattern :A}</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">{:cell (3 2), :pattern :B}</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">{:cell (3 1), :pattern :C}</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">{:cell (2 1), :pattern :B}</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">{:cell (2 0), :pattern :B}</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">{:cell (3 0), :pattern :A})</span>
</pre>
</div>

<p>
Lovely. Okay we don't care about the patterns any more once we have finished iterating, but we do want to change from cells to points on the canvas. Let's grab the ordered cells and use the canvas dimensions to turn them into points.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">cells-&gt;points</span> <span class="org-rainbow-delimiters-depth-2">[</span>cells iterations canvas-width<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-3">[</span>width-in-cells <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">js</span>/Math.pow 2 iterations<span class="org-rainbow-delimiters-depth-4">)</span>
        step-width <span class="org-rainbow-delimiters-depth-4">(</span>/ canvas-width width-in-cells<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">]</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">-&gt;&gt;</span> cells
         <span class="org-rainbow-delimiters-depth-4">(</span>map <span class="org-clojure-keyword">:cell</span><span class="org-rainbow-delimiters-depth-4">)</span>
         <span class="org-rainbow-delimiters-depth-4">(</span>map #<span class="org-rainbow-delimiters-depth-5">(</span>map * 1% 2%<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">(</span>repeat <span class="org-rainbow-delimiters-depth-6">[</span>step-width step-width<span class="org-rainbow-delimiters-depth-6">]</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">hilbert-curve-points</span> <span class="org-rainbow-delimiters-depth-2">[</span>iterations canvas-width<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">-&gt;</span> <span class="org-rainbow-delimiters-depth-3">(</span>hilbert-curve-cells iterations<span class="org-rainbow-delimiters-depth-3">)</span>
      <span class="org-rainbow-delimiters-depth-3">(</span>cells-&gt;points iterations canvas-width<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span>hilbert-curve-points 2 400<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-comment-delimiter">;</span><span class="org-comment">=&gt; ((0.0 0.0)</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">(100.0 0.0)</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">(100.0 100.0)</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">(0.0 100.0)</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">(0.0 200.0)</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">(0.0 300.0)</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">(100.0 300.0)</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">(100.0 200.0)</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">(200.0 200.0)</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">(200.0 300.0)</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">(300.0 300.0)</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">(300.0 200.0)</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">(300.0 100.0)</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">(200.0 100.0)</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">(200.0 0.0)</span>
<span class="org-comment-delimiter">;    </span><span class="org-comment">(300.0 0.0))</span>

</pre>
</div>

<canvas id="hilbert-canvas"
        width="600"
	height="600"
	class="canvas"></canvas>

<script type="application/x-scittle">

(def hc (js/document.getElementById "hilbert-canvas"))
(def hctx (.getContext hc "2d"))
(set! (.-lineWidth hctx 20))

(defn try-eval [v]
  (try (js/scittle.core.eval_string v)
    (catch js/Error e
      (str "ERROR: " e))))

(defn read-eval-input [input-id]
  (-> input-id
      js/document.getElementById 
      .-value
      try-eval))

(defn draw-line-from-points [context points]
  (.clearRect context 0 0 (.-width hc) (.-height hc))
  (.beginPath context)
  (.moveTo context (-> points first first) (-> points first second))
  (doseq [[x y] (rest points)]
    (.lineTo context x y))
  (.stroke context))

(set! (.-read_hilbert_points js/window)
      #(->> (read-eval-input "hilbert-input")
            (draw-line-from-points hctx)))

</script>
<body>
<textarea id="hilbert-input"
          class="code-textarea"
	  spellcheck="false">
(def rules 
  {:A {:path [[0 0] [0 1] [1 1] [1 0]]
   :next-iteration [:D :A :A :B]}
   :B {:path [[1 1] [0 1] [0 0] [1 0]]
   :next-iteration [:C :B :B :A]}
   :C {:path [[1 1] [1 0] [0 0] [0 1]]
   :next-iteration [:B :C :C :D]}
   :D {:path [[0 0] [1 0] [1 1] [0 1]]
   :next-iteration [:A :D :D :C]}})
   
(def init [{:cell [0 0] :pattern :A}])

(defn ->subcells
  [{:keys [cell pattern]}]
  (let [top-left-subcell (map (partial * 2) cell)
        path-step->subcells (fn [path-step]
                              (map + top-left-subcell
                                     path-step)) 
        path (->> rules
                  pattern
                  :path
                  (map path-step->subcells))
        cell-patterns (-> rules pattern :next-iteration)]
    (map (fn [cell pattern]
           {:cell cell :pattern pattern})
         path
         cell-patterns)))

(defn hilbert-curve-cells [iterations]
  (-> (iterate #(->> % (map ->subcells) (apply concat)) init)
      (nth iterations)))

(defn cells->points [cells iterations canvas-width]
  (let [width-in-cells (js/Math.pow 2 iterations)
        step-width (/ canvas-width width-in-cells)]
    (->> cells
         (map :cell)
         (map #(map * %1 %2) (repeat [step-width step-width])))))

(defn hilbert-curve-points [iterations canvas-width]
  (-> (hilbert-curve-cells iterations)
      (cells->points iterations canvas-width)))

(hilbert-curve-points 6 600)

</textarea>
<button onclick="read_hilbert_points()">Draw points</button>
</body>

<p>
That's it. Muck about with the code and see what results you can get.
</p>
</div>
</div>
</div>
</body>
</html>
